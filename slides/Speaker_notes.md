# Замітки доповідача — «Задача комівояжера (TSP)»

---

## Слайд 1 — Титул
- До вашої уваги доповідь на тему «Задача комівояжера (TSP): порівняння підходів розв’язання».  
- Доповідає Єрмолович Захар Максимович.  
- У доповіді розглядається реалізація та зіставлення кількох підходів у SWI-Prolog і Haskell, а також відтворюваність експериментів.  
- Вхідні дані задаються файлами формату `*.tsp`, а вихід подається як `cost=...` і `tour=[1,...,1]`.  

---

## Слайд 2 — Огляд роботи
- У роботі поєднано постановку задачі, реалізацію алгоритмів, автоматичну перевірку коректності та аналіз ефективності.  
- Для всіх реалізацій використано єдиний формат введення/виведення, щоб результати можна було зіставляти автоматично.  
- Порівнюються два підходи в Prolog (перебір і CLP(FD)) та контрольний перебір у Haskell.  
- Далі надається формальне визначення TSP, опис вхідних даних і критерій оптимальності.  

---

## Слайд 3 — Постановка TSP
- Задача комівояжера полягає у знаходженні найкоротшого замкненого маршруту, який відвідує кожне місто рівно один раз і повертається у стартове місто.  
- На вході використовується кількість міст `N` та матриця відстаней розміру `N×N`.  
- На виході формується тур у вигляді списку міст із поверненням у початок та його сумарна вартість `cost`.  
- Далі уточнюється формат інстансів `*.tsp` та правила обробки введення.  

---

## Слайд 4 — Дані та I/O
- Інстанс `*.tsp` описує матрицю відстаней, яка задає ваги переходів між містами.  
- Рядки, що починаються з `#`, ігноруються як коментарі.  
- Перший значущий рядок містить число `N`, після чого подається `N` рядків по `N` чисел.  
- Результат уніфіковано виводиться як `cost=...` та `tour=[1,...,1]`, що спрощує тестування та порівняння реалізацій.  
- Далі пояснюється складність задачі та мотивація вибраних підходів.  

---

## Слайд 5 — Складність і мотивація підходів
- TSP є класичною NP-складною задачею, тому кількість варіантів різко зростає зі збільшенням `N`.  
- Підхід перебору (bruteforce) гарантує знаходження оптимального туру, але має факторіальну складність через перебір перестановок.  
- Підхід CLP(FD) дозволяє описати задачу через обмеження та виконувати пошук із відсіканням невдалих гілок.  
- Контрольна реалізація перебору в Haskell використовується для зіставлення результатів і поведінки на однакових інстансах.  
- Далі розглядається реалізація перебору в Prolog і принцип формування туру.  

---

## Слайд 6 — Prolog bruteforce (generate & test)
- Перебір у Prolog організовано за схемою generate & test: спочатку генеруються всі можливі тури, а потім обирається оптимальний.  
- Старт маршруту фіксується в місті 1, а інші міста перебираються як перестановка множини `{2..N}`.  
- Замкнений тур формується з обов’язковим поверненням у стартове місто, що дає формат `[1,...,1]`.  
- Для кожного туру обчислюється сумарна вартість як сума відстаней між послідовними містами за матрицею.  
- Далі стисло пояснюються ключові предикати, що відповідають за генерацію кандидатів і підрахунок вартості.  

---

## Слайд 7 — Bruteforce: ключові предикати
- Головний предикат розв’язання виконує повний перебір кандидатів та повертає мінімальну вартість і відповідний тур.  
- Генерація кандидатів базується на перестановках та фіксації стартового міста для зменшення дублювання еквівалентних турів.  
- Підрахунок вартості туру винесено в окрему логіку, яка проходить по списку маршруту і сумує ребра з матриці.  
- Коректність туру забезпечується умовами: усі міста відвідано рівно один раз, маршрут замкнений, формат виводу уніфікований.  
- Далі розглядається підхід CLP(FD) як спосіб формалізації TSP через обмеження.  

---

## Слайд 8 — Prolog CLP(FD): модель через обмеження
- У CLP(FD) задача описується через змінні та обмеження, а не через явний перебір перестановок.  
- Використовується подання `Succs`, де кожне `Succs[I]` означає наступне місто після міста `I`.  
- Коректність єдиного гамільтонового циклу гарантується обмеженням `circuit(Succs)`.  
- Загальна вартість `Cost` задається як сума вартостей переходів `I -> Succs[I]`, узятих з матриці відстаней.  
- Оптимізація виконується під час пошуку за рахунок мінімізації `Cost` у процесі маркування змінних.  
- Далі пояснюється, як саме матриця відстаней зв’язується з вибором `Succs` через індексацію та `element/3`.  

---

## Слайд 9 — CLP(FD): обчислення вартості через element/3
- Матриця відстаней перетворюється у плоский список, щоб звернення до елементів було зручним у термінах обмежень.  
- Для кожного міста `I` та його наступника `S` обчислюється індекс елемента, що відповідає ребру `I -> S`.  
- Предикат `element/3` зв’язує індекс та значення відстані, роблячи вагу частиною системи обмежень.  
- Загальна вартість маршруту утворюється як сума всіх відповідних відстаней для `I=1..N`.  
- Далі описується відновлення спискового маршруту `tour=[1,...,1]` з подання `Succs`.  

---

## Слайд 10 — Відновлення туру з Succs
- Подання `Succs` описує цикл як відповідність “поточне місто → наступне місто”.  
- Тур відновлюється шляхом послідовного переходу від міста 1 за значеннями `Succs` рівно `N` разів.  
- Для уніфікації формату результату до кінця маршруту додається повернення у місто 1.  
- Обмеження `circuit/1` гарантує відсутність повторів і відвідування всіх міст рівно один раз.  
- Далі описуються правила тестування та відтворюваності запусків.  

---

## Слайд 11 — Тестування та відтворюваність
- Відтворюваність забезпечується фіксованим набором інстансів і уніфікованим форматом виводу для всіх реалізацій.  
- Перевірка коректності включає контроль формату туру, валідність обходу та зіставлення вартості `cost` між підходами на малих `N`.  
- Перебір використовується як еталон для перевірки правильності обмежувального підходу на тих інстансах, де перебір практично здійсненний.  
- Такий підхід дозволяє швидко виявляти помилки в читанні матриці, побудові циклу або підрахунку вартості.  
- Далі наводяться підсумкові висновки та порівняння підходів.  

---

## Слайд 12 — Висновки
- Підхід перебору є простим і гарантує оптимальний результат, однак стає неефективним зі зростанням `N` через факторіальну складність.  
- Підхід CLP(FD) дозволяє декларативно формалізувати TSP та виконувати оптимізаційний пошук із використанням обмежень.  
- Порівняння підходів демонструє наявність альтернативних реалізацій і підкреслює переваги логічного програмування у постановці задачі через обмеження.  
