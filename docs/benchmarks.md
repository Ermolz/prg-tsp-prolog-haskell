# Методика бенчмарків TSP

## Мета

Порівняти час виконання реалізацій TSP (Prolog bruteforce, Prolog CLP(FD), Haskell bruteforce) на інстансах різного розміру.

## Методика

- **Інструмент**: `/usr/bin/time -f "%e"` — час у секундах, переведення в мс.
- **Прогони**: 3 прогони на пару (алгоритм, інстанс).
- **Агрегація**: мінімальний час із трьох прогонів.
- **Інстанси**: n5_demo.tsp, n8_01.tsp, n10_01.tsp, n12_01.tsp (N = 5, 8, 10, 12).

## Команди відтворення

З кореня репозиторію:

```bash
./scripts/bench_prolog.sh
./scripts/bench_haskell.sh
```

Результати записуються в `results/benchmarks.csv`.

## Спостереження

1. **Факторіальна складність bruteforce** — час росте з (N−1)!. Для N=12 кількість перестановок ~40 млн; bruteforce на Prolog і Haskell виходить за межі прийнятного часу.

2. **Overhead CLP(FD) на малих N** — для N=5 і N=8 Prolog CLP(FD) повільніший за Prolog bruteforce через накладні витрати на постановку обмежень і labeling.

3. **Виграш CLP(FD) на середніх N** — для N=10 CLP(FD) швидший за обидва bruteforce. Обмеження дають відсікання гілок, які зменшують фактичний обсяг перебору.

4. **Різниця Prolog vs Haskell bruteforce** — на N=5 Haskell значно повільніший (1750 vs 320 мс) через старт runtime і завантаження; на N=10 Haskell швидший (1340 vs 6270 мс) завдяки ефективній реалізації перестановок та мінімуму.

5. **Межа N=12** — лише CLP(FD) вкладається в прийнятний час (~60 с); bruteforce для N=12 не вимірювався через очікувану тривалість.
