# Пояснення застосування CLP(FD) у задачі TSP

---

## Представлення туру через successor-список `Succs`
Нехай `N` — кількість міст. Використовується список:
- `Succs` — список довжини `N`;
- елемент `Succs[I] = J` означає: **з міста `I` перехід у місто `J`**.

Це представлення не є туром у форматі `[1,...,1]`, тому після знаходження `Succs` тур відновлюється обходом:
- старт у місті `1`;
- `N` кроків за successor-посиланнями;
- отримується список довжини `N+1`, який закінчується поверненням у `1`.

---

## Обмеження коректності циклу: `circuit/1`
Предикат `circuit(Succs)` задає глобальне обмеження:
- `Succs` описує **один цикл**, який проходить через усі вершини рівно один раз;
- забороняє розбиття на кілька коротших циклів (subtours);
- гарантує, що отриманий цикл є **гамільтоновим** (відвідує кожне місто рівно один раз).

Додатково задається область значень:
- `Succs ins 1..N` — кожен наступник є номером міста у діапазоні `1..N`.

---

## Обчислення вартості через `element/3`
Матриця відстаней `Matrix` (розміру `N×N`) перетворюється у плоский список:
- `Flat` — список довжини `N*N`, сформований “рядок за рядком”.

Для кожного міста `I` вводиться змінна вартості ребра `Di`, яка відповідає переходу `I -> Succs[I]`.
Індекс елемента у плоскому списку:
- `Idx #= (I - 1) * N + Succs[I]`

Тоді:
- `element(Idx, Flat, Di)` задає обмеження: `Di` дорівнює відстані з `I` до `Succs[I]`.

Загальна вартість:
- `sum(Ds, #=, Cost)` — сума всіх ребер `Di` дорівнює `Cost`.

Таким чином `Cost` є логічною змінною CLP(FD), зв’язаною з `Succs` через обмеження.

---

## Пошук та оптимізація: `labeling/2` з `min(Cost)`
Після постановки обмежень значення `Succs` ще не визначені конкретно — це лише допустима область і правила.
Конкретизація відбувається на етапі `labeling/2`:

- `labeling([ffc, min(Cost)], Succs)`

де:
- `min(Cost)` — пошук рішення з **мінімальною** вартістю;
- `ffc` — евристика вибору змінної (“first-fail combined”), яка зазвичай прискорює пошук.

Використання `once/1` забезпечує отримання одного (оптимального) рішення.

---

## Відновлення туру у форматі `[1,...,1]`
Оскільки модель працює з successor-формою, після пошуку тур відновлюється:
- старт `Current = 1`;
- на кожному кроці `Next = Succs[Current]`;
- додається `Next` у список;
- повторюється `N` разів.

Отримується:
- `Tour = [1, ..., 1]` довжини `N+1`.

---

## Висновок
CLP(FD) у цьому розв’язанні використовується для:
- декларативного опису циклу через `circuit/1`;
- зв’язування структури туру з вартістю через `element/3` і `sum/3`;
- оптимізації через `labeling([..., min(Cost)], ...)`.

На відміну від brute force, де основна робота — це перебір перестановок, CLP(FD) поєднує обмеження, пропагацію та керований пошук з оптимізацією.
